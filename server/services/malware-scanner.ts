// server/services/malware-scanner.ts
export interface ScanResult {
  threats: string[]; // heuristic-level threats (e.g. "URL: ...")
  sensitiveData: string[]; // human-readable matches like "AWS Access Key ID", "Stripe key"
  details?: Record<string, string[]>; // optional map name -> list of raw matches
}

const PATTERNS: { name: string; regex: RegExp; example?: string; severity?: "high" | "medium" | "low" }[] = [
  // AWS Access Key ID (AKIA...)
  { name: "AWS Access Key ID", regex: /\bAKIA[0-9A-Z]{16}\b/g, severity: "high" },

  // AWS secret access key (base64-ish 40 chars). Heuristic only.
  { name: "AWS Secret Access Key", regex: /\b(?<![A-Za-z0-9])[A-Za-z0-9/+=]{40}\b/g, severity: "high" },

  // Google service account private key (starts with "-----BEGIN PRIVATE KEY-----")
  { name: "Private Key PEM", regex: /-----BEGIN (?:RSA )?PRIVATE KEY-----[\s\S]{20,}-----END (?:RSA )?PRIVATE KEY-----/g, severity: "high" },

  // Supabase anon/public key (starts with "eyJ" jwt-like) â€” many services use base64 JWTs; this is heuristic
  { name: "JWT-like token", regex: /\beyJ[a-zA-Z0-9_\-]+?\.[a-zA-Z0-9_\-]+?\.[a-zA-Z0-9_\-]*\b/g, severity: "medium" },

  // Stripe secret keys: sk_live_..., sk_test_...
  { name: "Stripe secret key", regex: /\bsk_(live|test)_[0-9a-zA-Z]{24,}\b/g, severity: "high" },

  // Slack token: xoxb- or xoxp-
  { name: "Slack token", regex: /\bxox[boprs]-[0-9A-Za-z-]{8,}\b/g, severity: "high" },

  // Generic API key patterns e.g. key_XXXXXXXX
  { name: "Generic API key (key_...)", regex: /\bkey_[0-9A-Za-z-_]{16,}\b/g, severity: "medium" },

  // Firebase database secret (deprecated, but still)
  { name: "Firebase secret (DB)", regex: /\bAIza[0-9A-Za-z\-_]{35}\b/g, severity: "high" },

  // Heroku API key (32 hex)
  { name: "Heroku API key", regex: /\b[a-f0-9]{32}\b/gi, severity: "high" },

  // Generic long base64 / token (avoid false positives by requiring certain length)
  { name: "Long base64/token", regex: /\b[A-Za-z0-9-_]{40,}\b/g, severity: "medium" },
];

export function scan(content: string): ScanResult {
  const threats: string[] = [];
  const sensitiveData: string[] = [];
  const details: Record<string, string[]> = {};

  // Find patterns
  for (const p of PATTERNS) {
    const matches = Array.from(content.matchAll(p.regex)).map((m) => m[0]);
    if (matches.length) {
      details[p.name] = matches;
      sensitiveData.push(`${p.name} (${matches.length} match${matches.length > 1 ? "es" : ""})`);
      // optionally: push specific threats
      if (p.severity === "high") {
        threats.push(`${p.name} detected`);
      }
    }
  }

  // Optional: dedupe sensitiveData entries
  const uniqueSensitive = Array.from(new Set(sensitiveData));

  return {
    threats,
    sensitiveData: uniqueSensitive,
    details,
  };
}
