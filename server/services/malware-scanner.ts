// server/services/malware-scanner.ts
export interface ScanResult {
  clean: boolean; // true if no threats/sensitive data found
  threats: string[]; // heuristic-level threat labels (e.g. "URL: ...", "AWS Access Key ID detected")
  sensitiveData: string[]; // human-readable matches like "AWS Access Key ID (1 match)"
  details?: Record<string, string[]>; // optional map name -> list of raw matches
  confidence?: "low" | "medium" | "high"; // overall confidence that content is risky
}

/**
 * Pattern list:
 * - name: human label used in report
 * - regex: global /g to collect all matches
 * - severity: used to decide threat vs informational
 * - note: short explanation or example (optional)
 *
 * Keep patterns conservative to avoid noisy false positives.
 */
const PATTERNS: {
  name: string;
  regex: RegExp;
  severity: "high" | "medium" | "low";
  note?: string;
}[] = [
  // AWS Access Key ID (AKIA...) — very specific
  { name: "AWS Access Key ID", regex: /\bAKIA[0-9A-Z]{16}\b/g, severity: "high", note: "AKIA..." },

  // AWS secret key is 40 base64-like chars; ensure not to match small tokens — require surrounding whitespace/punctuation
  { name: "AWS Secret Access Key (likely)", regex: /(?<![A-Za-z0-9/+=])[A-Za-z0-9/+=]{40}(?![A-Za-z0-9/+=])/g, severity: "high", note: "40-char base64-like" },

  // PEM private key block (multi-line)
  { name: "Private Key PEM", regex: /-----BEGIN (?:RSA )?PRIVATE KEY-----[\s\S]{50,}-----END (?:RSA )?PRIVATE KEY-----/g, severity: "high", note: "PEM private key block" },

  // Google API key / Firebase server key (AIza...)
  { name: "Google API Key / Firebase", regex: /\bAIza[0-9A-Za-z\-_]{35}\b/g, severity: "high", note: "AIza..." },

  // Stripe secret keys: sk_live_..., sk_test_...
  { name: "Stripe secret key", regex: /\bsk_(live|test)_[0-9a-zA-Z]{24,}\b/g, severity: "high", note: "sk_live_/sk_test_" },

  // Slack bot/user tokens (xoxb-, xoxp-, xoxa-)
  { name: "Slack token", regex: /\bxox(?:b|p|a)-[0-9A-Za-z-]{8,}\b/g, severity: "high", note: "xoxb-/xoxp-/xoxa-" },

  // Heroku API key (32 hex-ish) but avoid matching short hex -> require boundaries and length
  { name: "Heroku API key (hex32)", regex: /\b[0-9a-f]{32}\b/gi, severity: "high", note: "32 hex chars" },

  // JWT-like tokens starting with eyJ (common for many services). Be careful: many benign strings start with eyJ in text,
  // so require pattern to be long enough (2+ segments) and include base64url characters.
  { name: "JWT-like token", regex: /\beyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.([A-Za-z0-9_-]{0,})\b/g, severity: "medium", note: "eyJ... JWT-like" },

  // Generic API key patterns (key_..., api_key=..., token=...)
  { name: "Generic API key label (key_/api_key/token=)", regex: /\b(?:key_|api_key=|api-key=|token=)[A-Za-z0-9\-_\.]{16,}\b/gi, severity: "medium", note: "labelled key/token" },

  // Long base64/url-safe token (>=40 chars). Conservative to reduce FP.
  { name: "Long token / base64-like string", regex: /\b[A-Za-z0-9\-_]{40,}\b/g, severity: "medium", note: "long base64/urlsafe token" },

  // Generic possible credit-card/IBAN detection intentionally omitted to avoid PII false positives here.
];

/**
 * Helper: dedupe array preserving order
 */
function dedupe<T>(arr: T[]): T[] {
  return Array.from(new Set(arr));
}

/**
 * Main scan function
 */
export function scan(content: string): ScanResult {
  const threats: string[] = [];
  const sensitiveData: string[] = [];
  const details: Record<string, string[]> = {};

  if (!content || typeof content !== "string") {
    return { clean: true, threats: [], sensitiveData: [], details: {}, confidence: "low" };
  }

  // Run each pattern
  for (const p of PATTERNS) {
    try {
      const matches = Array.from(content.matchAll(p.regex)).map((m) => m[0]).filter(Boolean);
      if (matches.length) {
        details[p.name] = dedupe(matches);
        sensitiveData.push(`${p.name} (${matches.length} match${matches.length > 1 ? "es" : ""})`);

        // Add a heuristic threat entry for high severity items
        if (p.severity === "high") {
          // include an example truncated match where reasonable (avoid logging huge private keys)
          const example = details[p.name][0];
          const short = example && example.length > 80 ? example.slice(0, 40) + "..." + example.slice(-20) : example;
          threats.push(`${p.name} detected: ${short}`);
        } else if (p.severity === "medium") {
          // medium severity -> info-level threat (kept but less urgent)
          threats.push(`${p.name} (suspicious)`);
        } else {
          // low severity -> just record in sensitiveData/details
        }
      }
    } catch (e) {
      // in case a regex is malformed or matchAll fails, skip that pattern
      console.warn("[malware-scanner] pattern error:", p.name, e);
    }
  }

  // Special-case: detect explicit URLs as threats (routes.ts filters URL-marked threats later).
  const urlMatches = Array.from(content.matchAll(/\bhttps?:\/\/[^\s)'"`<>{}]+/gi)).map((m) => m[0]);
  if (urlMatches.length) {
    const urls = dedupe(urlMatches);
    // push a concise URL threat (routes.ts currently strips URL-prefixed threats, but keep here too)
    for (const u of urls.slice(0, 10)) {
      threats.push(`URL:${u}`);
    }
    details["Found URLs"] = urls;
  }

  // Final aggregation and heuristics
  const uniqueSensitive = dedupe(sensitiveData);
  const uniqueThreats = dedupe(threats);

  const hasHigh = uniqueThreats.some((t) => /detected|Stripe|AWS|Private Key|Heroku|Slack|Stripe/i.test(t));
  const hasAny = uniqueThreats.length > 0 || uniqueSensitive.length > 0;

  const confidence: ScanResult["confidence"] = hasHigh ? "high" : hasAny ? "medium" : "low";

  return {
    clean: !hasAny,
    threats: uniqueThreats,
    sensitiveData: uniqueSensitive,
    details: Object.keys(details).length ? details : undefined,
    confidence,
  };
}

/**
 * Export an object named `malwareScanner` so your routes can import:
 * import { malwareScanner } from "./services/malware-scanner";
 *
 * This keeps API consistent with your earlier code.
 */
export const malwareScanner = {
  scan,
};
